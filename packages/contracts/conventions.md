# Contracts Conventions

Purpose

This document defines the conventions used for contracts across the codebase.

A “contract” is any cross-boundary guarantee that multiple components rely on, such as:

API request/response shapes

Error model formats

Event envelope and payload schemas

Dataset formats used by pipelines

Search document structure

Shared type definitions exposed to other packages/services

The goal is to ensure contracts are stable, versioned, testable, and resistant to drift.

Core Principles
1) One Source of Truth

Each contract must have a single canonical definition (schema/type file).
Avoid re-declaring the same shapes in multiple places.

2) Explicit Versioning

If a contract can change in a breaking way, it must be versioned.

3) Backward Compatibility First

Prefer additive changes. Breaking changes require:

a migration plan

parallel support (if needed)

explicit version bumps

4) Test the Boundary

Contracts must be protected by:

contract tests (tests/contract/)

schema validation (runtime) where applicable

What Counts as a Contract

A change is “contract-impacting” if it affects:

external clients (public API consumers)

internal consumers (workers, services, packages)

persisted formats (datasets, events stored/replayed)

derived systems (search docs, enrichment artifacts)

If another component depends on it, it’s a contract.

Naming Conventions
Stable Identifiers

Contracts should have stable identifiers that do not change casually:

API endpoints: path + method

Events: domain.entity.past_tense_action

Error codes: stable strings (no random renames)

Schema names: explicit, readable, versioned when necessary

Event Naming (Reminder)

Use past tense and dot-namespace:

ingestion.dataset_created

search.index_rebuilt

ai.enrichment_completed

See: docs/specs/events.md.

Versioning Strategy
When to Version

Version a contract when:

Removing or renaming fields

Changing field types

Changing semantics in a way that breaks consumers

Changing required/optional rules incompatibly

How to Version

Use one of these strategies:

In-schema version field (recommended for events)

version: 1, version: 2, etc.

Versioned schema files

*.v1.schema.ts, *.v2.schema.ts (or equivalent)

Endpoint versioning (only when necessary)

Prefer additive changes; avoid URL versioning unless required.

Compatibility Rules
Additive Changes (Preferred)

Safe changes include:

Adding optional fields

Adding new enum variants (if consumers handle unknown values safely)

Adding new endpoints/events without changing existing ones

Breaking Changes (Require Versioning)

Breaking changes include:

Removing fields

Renaming fields

Making optional → required

Changing types (string → number, etc.)

Changing semantics of existing fields

Runtime Validation

Where contracts cross trust boundaries (external inputs, events, datasets), use runtime validation:

Validate inbound API payloads

Validate event payloads (producer and consumer side)

Validate datasets generated by pipelines

Schema validation prevents silent drift and reduces production incidents.

Ownership and Review

Contract changes require careful review.

Rules:

The owning package/service owns the contract definition

Consumers must be notified for breaking changes

Contract tests must be updated intentionally (never “just make it pass”)

Documentation Requirements

Any contract change should be accompanied by updates to:

packages/contracts/changelog.md

relevant docs under docs/specs/ or services/*

migration or rollout notes if applicable

Anti-Patterns (Avoid)

Copy-pasting types across services

“Quick” breaking changes without versioning

Implicit semantics not written down

Tests that assert internal implementation details instead of boundary behavior

Using derived systems (search) as sources of truth for contracts

Summary

Contracts are the glue of the system. We keep them:

single-source-of-truth

versioned when needed

backward-compatible by default

validated at boundaries

protected by contract tests

If a change can break another component, treat it like a contract change and handle it with discipline.

End of Contracts Conventions
